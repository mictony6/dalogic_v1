import {GameState} from "@/components/game-state";
import type {Board} from "@/actors/board/board";
import {state} from "@/store/store";
import type {CaptureMove} from "@/components/capture-move";
import {type Engine, Timer, Vector} from "excalibur";
import {CheckDoubleCapture} from "@/states/check-double-capture";
import {AudioType, GameAudio} from "@/audio/GameAudio";
import { SwitchingTurn } from "./switching-turn";
import Swal from "sweetalert2";
import { millisecondsToMinutesSeconds } from "@/components/helpers";

export class Capture extends GameState{
  static stateName = "capture";
  private modalClosed: boolean = false;
  private answeredCorrect:boolean = false;
  private timer :  Timer = new Timer({
    fcn: () => {
      this.modalClosed = true;
      const submit = this.getSubmitButtonElement();
      submit.click();
    },
    interval: 30000,
  
  })
  lastTimeLeft: string;
  timeLeft: string;

  constructor() {
    super();
    this.stateName = Capture.stateName;

    addEventListener("answer" , (e : CustomEvent) => {
      const board : Board = state.boardManager.currentBoard;
      const captureMove: CaptureMove = board.selectedMove as CaptureMove;

      console.log(e.detail, captureMove.points.toString(2));
      this.answeredCorrect = (parseInt(e.detail, 2) === captureMove.points);
      if (this.answeredCorrect){
        new GameAudio().play(AudioType.SCORE);
        if (state.currentPlayerID === state.player["playerID"]){
          Swal.fire({
            title: 'Correct!',
            icon: 'success',
            position: "bottom-left",
            confirmButtonText: `+${captureMove.points} points!`,
            toast: true,
            timer: 2000,
            customClass:{
              title: 'alert-title',
              confirmButton: 'alert-button'
            }
          })
        } else {
          Swal.fire({
            title: 'Opponent Correct!',
            icon: "info",
            toast: true,
            position: "bottom-left",
            timer: 2000,
            customClass:{
              title: 'alert-title-error',
            }
          })
        }
      } else {
        new GameAudio().play(AudioType.ERROR);
        if (state.currentPlayerID === state.player["playerID"]){
          Swal.fire({
            title: 'Ooops!',
            icon: 'error',
            position: "bottom-left",
            confirmButtonText: `You lost ${captureMove.points} points to opponent!`,
            toast: true,
            timer: 2000,
            customClass:{
              title: 'alert-title-error',
              confirmButton: 'alert-button-error'
            }
          })
        } else {
          Swal.fire({
            title: 'Nice! Opponent Wrong.',
            icon: 'info',
            position: "bottom-left",
            confirmButtonText: `+${captureMove.points} points to you!`,
            toast: true,
            timer: 2000,
            customClass:{
              title: 'alert-title',
              confirmButton: 'alert-button'
            }
          });
        }
      }
      this.modalClosed = true;
     });

  }


  onEnter(engine: Engine) {
    this.modalClosed = false;
    this.answeredCorrect = false;

    const board = state.boardManager.currentBoard;
    const modal = this.getModalElement();

    const captureMove : CaptureMove = board.selectedMove as CaptureMove;
    const a = captureMove.srcPos.piece.binRep;
    const b = captureMove.mid.piece.binRep;

    const modalHeading = document.getElementById("equation")
    modalHeading.innerText = `${a} ${captureMove.operationName} ${b}`;

    const textInput = this.getAnswerInputElement();
    const submit = this.getSubmitButtonElement();

    if (state.currentPlayerID !== state.player["playerID"]){
      textInput.readOnly = true;
      submit.disabled = true;
    }else{
      textInput.readOnly = false;
      submit.disabled = false;
    }
  
    if (modal && textInput) {
        modal.showModal();
        textInput.value = "";
      } else {
        console.error("Modal or input element not found");
      }

    engine.add(this.timer);
    this.timer.reset();
    this.timer.start();
  }

  onExit(engine: Engine): void {
    this.timer.reset();
    engine.remove(this.timer);
  }



  onUpdate(engine:Engine, delta:number) {

    const currentTimeLeft  = millisecondsToMinutesSeconds(this.timer.timeToNextAction);

    
    if (this.lastTimeLeft !== currentTimeLeft){
      this.timeLeft = currentTimeLeft;      
      dispatchEvent(new CustomEvent("input-timer-tick", {detail:this.timeLeft.substring(3)}));
      this.lastTimeLeft = currentTimeLeft;
    }
    // pause the game until the user answers the question
    if (!this.modalClosed){
      return;
    }


    const board : Board = state.boardManager.currentBoard;
    if (!board.selectedMove){
      throw new Error("No move selected");
    }

    const movingPiece = board.selectedMove.srcPos.piece;
    const destTile = board.selectedMove.destPos.tile;

    const destPos : Vector = destTile.getGlobalPos();
    const piecePos : Vector = movingPiece.getGlobalPos();
    if (piecePos.squareDistance(destPos) <= 50){
      // if the piece is close enough to the destination tile, move it there
      if (destTile.children.length > 0){
        throw new Error("Tile already has a piece");
      } else {
        board.selectedMove.commit(this.answeredCorrect);
      }
      movingPiece.z = 1;
      movingPiece.vel = Vector.Zero;
      movingPiece.pos = Vector.Zero;
      board.resetSelections();
      if (board.selectedMove.destPos.tile.row > 0 &&  board.selectedMove.destPos.tile.row < 7){
        this.nextState = CheckDoubleCapture.stateName;
      } else{
        this.nextState = SwitchingTurn.stateName; 
      }
    }else{
      movingPiece.z = 9;
      // move the piece towards the destination tile
      movingPiece.vel = movingPiece.pos.add(destPos.sub(piecePos).normalize().scale(300 ));

    }
  }

  getModalElement() {
    return document.getElementById("dialog") as HTMLDialogElement;
  }
  
  getAnswerInputElement() {
    return document.getElementsByClassName("answer-input")[0] as HTMLInputElement;
  }

  getSubmitButtonElement() {
    return document.getElementsByClassName("answer-button")[0] as HTMLButtonElement;
  }

}